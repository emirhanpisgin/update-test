import Updater from "basic-electron-updater";
import { app, BrowserWindow, ipcMain } from "electron";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const updater = new Updater({
    repo: "emirhanpisgin/update-test",
    autoDownload: false, // Changed to false for manual control
    allowPrerelease: false,
    channel: "latest",
    debug: true,
});

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
    app.quit();
}

let mainWindow: BrowserWindow | null = null;

// Logging function to send logs to renderer
const sendLog = (level: 'info' | 'warn' | 'error' | 'success', message: string, details?: any): void => {
    const log = {
        id: Date.now().toString(),
        timestamp: new Date().toLocaleTimeString('en-US', { 
            hour12: false, 
            hour: '2-digit', 
            minute: '2-digit', 
            second: '2-digit' 
        }),
        level,
        message,
        details
    };
    
    if (mainWindow && mainWindow.webContents) {
        mainWindow.webContents.send("updater-log", log);
    }
    
    // Also log to console for debugging
    console.log(`[${log.timestamp}] [${level.toUpperCase()}] ${message}`, details || '');
};

const createWindow = (): void => {
    mainWindow = new BrowserWindow({
        height: 800,
        width: 1200,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    });
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    
    // Only open dev tools in development
    if (process.env.NODE_ENV === 'development') {
        mainWindow.webContents.openDevTools();
    }

    // --- Enhanced Updater event forwarding with logging ---
    const sendUpdateState = (state: any): void => {
        if (mainWindow && mainWindow.webContents) {
            mainWindow.webContents.send("update-state", state);
        }
    };

    updater.on("update-available", (info) => {
        sendLog('success', `Update available: v${info.version}`, info);
        sendUpdateState({ type: "update-available", info });
    });
    
    updater.on("update-not-available", () => {
        sendLog('info', 'No updates available');
        sendUpdateState({ type: "update-not-available" });
    });
    
    updater.on("download-progress", (progress) => {
        const percent = progress.percent?.toFixed(1) || '0';
        const transferred = progress.transferred ? (progress.transferred / 1024 / 1024).toFixed(1) : '0';
        const total = progress.total ? (progress.total / 1024 / 1024).toFixed(1) : '0';
        
        sendLog('info', `Download progress: ${percent}% (${transferred}MB / ${total}MB)`, progress);
        sendUpdateState({ type: "downloading", progress });
    });
    
    updater.on("downloaded", (filePath) => {
        sendLog('success', 'Update downloaded successfully', { filePath });
        sendUpdateState({ type: "downloaded", filePath });
    });
    
    updater.on("error", (err) => {
        const errorMessage = err.message || String(err);
        sendLog('error', `Update error: ${errorMessage}`, { error: err });
        sendUpdateState({ type: "error", error: errorMessage });
    });

    // Additional event listeners for more detailed logging
    updater.on("checking-for-update", () => {
        sendLog('info', 'Checking for updates...');
        sendUpdateState({ type: "checking" });
    });

    // Log initial app information
    sendLog('info', `Application started - v${app.getVersion()}`);
    sendLog('info', `Platform: ${process.platform} ${process.arch}`);
    sendLog('info', `Electron: ${process.versions.electron}`);
    sendLog('info', `Node: ${process.versions.node}`);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", () => {
    createWindow();
    
    // Listen for manual update check from renderer
    ipcMain.on("check-for-updates", async (event) => {
        try {
            sendLog('info', 'Manual update check initiated by user');
            await updater.checkForUpdates();
        } catch (err) {
            const errorMessage = err.message || String(err);
            sendLog('error', `Update check failed: ${errorMessage}`, { error: err });
            if (mainWindow && mainWindow.webContents) {
                mainWindow.webContents.send("update-state", { type: "error", error: errorMessage });
            }
        }
    });
    
    // Listen for manual download trigger from renderer
    ipcMain.on("download-update", async (event) => {
        try {
            sendLog('info', 'Download initiated by user');
            await updater.downloadUpdate();
        } catch (err) {
            const errorMessage = err.message || String(err);
            sendLog('error', `Download failed: ${errorMessage}`, { error: err });
            if (mainWindow && mainWindow.webContents) {
                mainWindow.webContents.send("update-state", { type: "error", error: errorMessage });
            }
        }
    });
    
    // Listen for install update request from renderer
    ipcMain.on("install-update", async (event) => {
        try {
            sendLog('info', 'Installing update and restarting application...');
            await updater.applyUpdate();
        } catch (err) {
            const errorMessage = err.message || String(err);
            sendLog('error', `Install failed: ${errorMessage}`, { error: err });
            if (mainWindow && mainWindow.webContents) {
                mainWindow.webContents.send("update-state", { type: "error", error: errorMessage });
            }
        }
    });
    
    // Handle get app version request
    ipcMain.handle("get-app-version", () => {
        return app.getVersion();
    });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
        app.quit();
    }
});

app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
